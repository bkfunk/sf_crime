<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3 Test</title>
    <!--<link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/cupertino/jquery-ui.css">-->
    <script type="text/javascript" src="lib/d3/d3.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.stats.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/colorbrewer/colorbrewer.js"></script>
    <script type="text/javascript" src="lib/topojson/topojson.v1.min.js"></script>
    <!--<script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>-->
    <!--<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//code.jquery.com/ui/1.10.4/jquery-ui.js"></script>-->
    
    <script type="text/javascript">
      function _do(f) {
        /* I get tired of all the "fn_name(" + arg + ")" business,
          so I use _do to take the (string) name of a function, then any number
          of arguments, and append them together into a string */
        var args = ""
        for (i=1; i < arguments.length; i++) {
          args += (i != 1) ? ", " + arguments[i] : arguments[i];
        }
        return f + "(" + args + ")";
      }
      
      
      function extractField(dataset, fieldName) {
        // Create field object, starting with the label
        var field = { label: fieldName };
        
        // Create an array of numeric (float) values
        field.values = dataset.map(function(d) {
          return parseFloat(d[fieldName]);
        });
        
        // Create an array of string values
        field.stringValues = dataset.map(function(d) {
          return d[fieldName];
        });
        
        // Create minimum and maximum functions for the field
        // This is just a shorthand.
        field.getMin = function() { return d3.min(field.values); };
        field.getMax = function() { return d3.max(field.values); };
        
        // Unlike the overall min/max, the selected min/max are set by us,
        // so they don't need to be functions, since they don't reflect the
        // dynamic state of the data
        field.selected = {
          min: field.getMin(),
          max: field.getMax()
        };
        
        // The function to select for values
        field.selected.selector = function(element) {
          return (element >= field.selected.min && element <= field.selected.max)
        };
        
        // A function returning the selected values
        /*field.selected.getValues = function() {
          return field.values.filter(field.selected.selector);
        };*/
        
        return field;
      }
    </script>
    
    <style>
    
    .tract-06075030800 {
      stroke: red;
    }
    #main {
      clear: both;
      float: left;
      margin: auto;
    }
    #info {
      clear: both;
      margin: auto;
      text-align: center;
      height: 1.2em;
    }
    #scatter-group-container {
      float: left;
      width: 600px;
      height: 600px;
      border: 1px solid blue;
    }
    #map-group-container {
      float: left;
      width: 600px;
      height: 600px;
      border: 1px solid gray;
    }
    #y-density-container {
      float: left;
    }
    #scatter-container {
      float: left;
      clear: left;
    }
    #corner-container {
      clear: right;
      float: left;
    }
    #x-density-container {
      float: left;
    }
    
    
    #y-density-slider {
      float: left;
    }
    
    
    circle {
      opacity: .3;
    }
    circle:hover {
      opacity: 1;
    }
    .text {
      clear: both;
    }
    svg {
      float: left;
      border: 1px dashed lightgray;
    }
    .axis path,
    .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
    }
    
    .axis text {
        font-family: sans-serif;
        font-size: 11px;
    }
    .line {
      fill: none;
      stroke: #999;
      stroke-width: 1px;
    }
    
    .area {
      fill: lightblue;
      stroke-width: 0;
      fill-opacity: .5;
    }
    
    #xden-highlight .line,
    #yden-highlight .line {
      stroke-width: 2px;
      stroke: #000;
      stroke-opacity: 1;
    }
    
    .brush .extent {
      stroke: #fff;
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="info">
        
      </div>
      <div id="scatter-group-container">
        
        <div id="scatter-container" class="scatter plot-container">
        </div>
        <div id="y-density-container" class="y density plot-container">
          <!--<div id="y-density-slider" class="slider"></div>-->
        </div>
        
        <div id="x-density-container" class="x density plot-container">
        </div>
        <div id="corner-container">
        </div>
      </div>
      <div id="map-container">
      </div>
    </div>
    
    <script type="text/javascript">
    var color;
      // Create global variables
      var dataset; // Loaded from csv, contains all variables
      var data; // Contains only the data for a particular plot
      var kden;
      
      // Margins/Width/Height for scatter
      var scatter_margin = {top: 20, right: 10, bottom: 40, left: 40};
      var scatter_width = 500 - scatter_margin.left - scatter_margin.right;
      var scatter_height = 500 - scatter_margin.top - scatter_margin.bottom;
      
      // Margins/Long-dim/Short-dim
      var density_margin = {top: 5, right: 40, bottom: 20, left: 5};
      var xden_height = scatter_width / 5 - density_margin.top - density_margin.bottom;
      var yden_width = scatter_height / 5 - density_margin.left - density_margin.right;
      
      // Radius for points
      var r = scatter_width / 100;
      
      
      
    /* SCATTER PLOT */
      var scatter_xScale = d3.scale.linear();
      var scatter_xAxis = d3.svg.axis().scale(scatter_xScale).orient("bottom");
      
      var scatter_yScale = d3.scale.linear();
      var scatter_yAxis = d3.svg.axis().scale(scatter_yScale).orient("left");
      
      var scatter_svg = d3.select("#scatter-container")
          .append("svg")
            .attr("width", scatter_width + scatter_margin.left + scatter_margin.right)
            .attr("height", scatter_height + scatter_margin.top + scatter_margin.bottom)
          .append("g")
            .attr("transform", _do("translate", scatter_margin.left, scatter_margin.top));
      
      // Create clip path
      scatter_svg.append("clipPath")
            .attr("id", "scatter-clip")
          .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", scatter_width)
            .attr("height", scatter_height);
      
      var circlesg = scatter_svg.append("g")
                          .attr("id", "circles")
                          .attr("clip-path", "url(#scatter-clip)");
                        
      var circles;
      
      scatter_svg.append("g")
          .attr("class", "axis x-axis")
          .attr("transform", _do("translate", 0, scatter_height));
      
      scatter_svg.append("g")
          .attr("class", "axis y-axis");
          //.attr("transform", _do("translate", 0, 0));
      
      
    /* DENSITY PLOTS */
      // Create density/corner SVGs    
      var xden_svg = d3.select("#x-density-container")
          .append("svg")
            .attr("width", scatter_width + scatter_margin.left + scatter_margin.right)
            .attr("height", xden_height + density_margin.top + density_margin.bottom)
          .append("g")
            .attr("transform", _do("translate", scatter_margin.left, density_margin.top));
      
      var yden_svg = d3.select("#y-density-container")
          .append("svg")
            .attr("width", yden_width + density_margin.left + density_margin.right)
            .attr("height", scatter_height + scatter_margin.top + scatter_margin.bottom)
          .append("g")
            .attr("transform", _do("translate", density_margin.left, scatter_margin.top));
            
      var corner_svg = d3.select("#corner-container")
          .append("svg")
            .attr("width", yden_width + density_margin.left + density_margin.right)
            .attr("height", xden_height + density_margin.top + density_margin.bottom);
            
      // Create clip paths
      xden_svg.append("clipPath")
              .attr("id", "xden-clip")
            .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", scatter_width)
              .attr("height", xden_height);
              
      yden_svg.append("clipPath")
              .attr("id", "yden-clip")
            .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", yden_width)
              .attr("height", scatter_height);
      
      
      // Create scales        
      var xden_xScale = d3.scale.linear()
            .range([0, scatter_width]);
      var xden_yScale = d3.scale.linear()
            .range([xden_height, 0]);
            
      var yden_xScale = d3.scale.linear() // note that "x" value is VERTICAL
            .range([yden_width, 0]);
      var yden_yScale = d3.scale.linear() // note that "y" value is HORRIZONTAL
            .range([scatter_height, 0]);
      
      // Axes
      var xden_xAxis = d3.svg.axis()
              .scale(xden_xScale)
              .orient("bottom");
              
      var yden_xAxis = d3.svg.axis()
              .scale(yden_yScale)
              .orient("right");
      
      xden_svg.append("g")
        .attr("class", "axis xden-axis xden-x-axis")
        .attr("transform", _do("translate", 0, xden_height));
        
      yden_svg.append("g")
        .attr("class", "axis yden-axis yden-x-axis")
        .attr("transform", _do("translate", yden_width, 0));
      
      
      var xden_line = d3.svg.line();
      var yden_line = d3.svg.line();
      
      var xden_line_path = xden_svg.append("path")
          .attr("clip-path", "url(#xden-clip)");
      var yden_line_path = yden_svg.append("path")
          .attr("clip-path", "url(#yden-clip)");
      
      var xden_select_area = d3.svg.area();
      var yden_select_area = d3.svg.area();
      
      var xden_select_line = d3.svg.line();
      var yden_select_line = d3.svg.line();
      
      var xden_highlight = xden_svg.append("g")
            .attr("id", "xden-highlight")
            .attr("clip-path", "url(#xden-clip)")
      var yden_highlight = yden_svg.append("g")
            .attr("id", "yden-highlight")
            .attr("clip-path", "url(#yden-clip)")
            
      var xden_select_area_path = xden_highlight.append("path");
      var yden_select_area_path = yden_highlight.append("path");
      var xden_select_line_path = xden_highlight.append("path");
      var yden_select_line_path = yden_highlight.append("path");
            
      var xden_select_handle = d3.svg.arc()
          .outerRadius(xden_height / 8)
          .startAngle(0)
          .endAngle(function(d, i) { return i ? -Math.PI : Math.PI; });
      var yden_select_handle = d3.svg.arc()
          .outerRadius(yden_width / 8)
          .startAngle(Math.PI / 2)
          .endAngle(function(d, i) { return i ? -Math.PI / 2 : 3/2 * Math.PI; });
      
      
      var xden_brush = d3.svg.brush();
            //.x(xden_xScale)
            //.extent([data.x.selected.min, data.x.selected.max])
            //.on("brushstart", brushstart)
            //.on("brush", brushmove)
            //.on("brushend", brushend);
            
        var xden_brushg = xden_svg.append("g")
          .attr("class", "brush")
          //.call(xden_brush);
        xden_brushg.selectAll("rect")
          .attr("height", xden_height);
        
        
        var yden_brush = d3.svg.brush();
            //.x(xden_xScale)
            //.extent([data.x.selected.min, data.x.selected.max])
            //.on("brushstart", brushstart)
            //.on("brush", brushmove)
            //.on("brushend", brushend);
            
        var yden_brushg = yden_svg.append("g")
          .attr("class", "brush")
          //.call(xden_brush);
        yden_brushg.selectAll("rect")
          .attr("width", yden_width);
        
        /*  
        xden_brushg.selectAll(".resize").append("path")
          .attr("transform", "translate(0," +  xden_height / 2 + ")")
          .attr("d", arc);*/
      
      
      // Make interaction functions
      function mouseOverCircle(d) {
        d3.select("#info").html("<strong>Tract ID:</strong> " + d.id
                        + "; <strong>" + data.x.label + "</strong>: " + d.x
                        + "; <strong>" + data.y.label + "</strong>: " + parseFloat(d.y).toFixed(2));
      }
      
      
      
      
      
      
      
      // Initialize vis      
      function generateVis() {
        
        data = {
          x: extractField(dataset, "no_car_pct"),
          y: extractField(dataset, "vehicle theft (rate)"),
          id: extractField(dataset, "tract_id")
        }
        data.data = d3.zip(data.x.values, data.y.values, data.id.values)
                      .map(function(d) {
                        return {
                          x: d[0],
                          y: d[1],
                          id: d[2]
                        };
                      });
        
        data.isSelected = function(d) {
          return ((data.x.selected.min <= d.x && d.x <= data.x.selected.max) &&
                  (data.y.selected.min <= d.y && d.y <= data.y.selected.max));
        };
        
        data.x.kde = science.stats.kde().sample(data.x.values);
        data.y.kde = science.stats.kde().sample(data.y.values);
        data.x.density = { values: data.x.kde(data.x.values)
                                      .map(function(d) {
                                        return {x: d[0],
                                                y: d[1]};
                                      })};
        data.y.density = { values: data.y.kde(data.y.values)
                                      .map(function(d) {
                                        return {x: d[0],
                                                y: d[1]};
                                      })};
        data.x.density.sortedValues = data.x.density.values.sort(function(a,b) { return a.x - b.x; });
        data.y.density.sortedValues = data.y.density.values.sort(function(a,b) { return a.x - b.x; });
        
        
        bind_data(data);
        updateScatterAxes();
        updateScatterCircles();
        
        updateDensityAxes();
        updateDensity();
        
      }
      
      function bind_data(data) {
        circles = circlesg.selectAll("circle").data(data.data);//.filter(data.isSelected));
        
        xden_line_path.datum(data.x.density.sortedValues)
          .attr("class", "line xden-line");  
        yden_line_path.datum(data.y.density.sortedValues)
          .attr("class", "line yden-line");
          
        
      }
      
      function updateScatterAxis(axis) {
        if (axis.indexOf("x") !== -1) {
          scatter_xScale.domain([data.x.selected.min, data.x.selected.max])
                                .range([0, scatter_width]);
          scatter_svg.select(".x-axis").call(scatter_xAxis);
        }
        if (axis.indexOf("y") !== -1) {
          scatter_yScale.domain([data.y.selected.min, data.y.selected.max])
                                .range([scatter_height, 0]);                   
          scatter_svg.select(".y-axis").call(scatter_yAxis);
        }
        
      }
      function updateScatterAxes() {
        updateScatterAxis("xy");
      }
      
      function updateScatterCirclePositions(axis) {
        if (typeof axis === "undefined") {
          axis = "xy";
        }
        if (axis.indexOf("x") !== -1) {
          circles.attr("cx", function(d, i) { return scatter_xScale(d.x); });
        }
        if (axis.indexOf("y") !== -1) {
          circles.attr("cy", function(d, i) { return scatter_yScale(d.y); });
        }
      }
      
      function updateScatterCircles() {
        // ENTER
        circles.enter()
          .append("circle")
            //.attr(
              //"cx", function(d, i) { console.log(i + ": " + d.x + " -> " + scatter_xScale(d.x)); return scatter_xScale(d.x); }
              //)
            .attr({
              //cx: function(d, i) { return scatter_xScale(d.x); },
              //cy: function(d, i) { return scatter_yScale(d.y); },
              r: 0,
              fill: "blue",
              stroke: "darkblue",
              "stroke-width": r/3,
              "fill-opacity": .4,
              "stroke-opacity": .6,
            })
            .on("mouseover",function(d) { mouseOverCircle(d, (data.x.label), data.y.label) })
            .transition()
              .attr("r", r);
        
        updateScatterCirclePositions();
        // EXIT
        circles.exit()
            .transition()
              .style("fill-opacity", 1e-6)
              .style("stroke-opacity", 1e-6)
              .remove();
      }
      
      function updateDensityAxes() {
        xden_xScale.domain([0, d3.max(data.x.density.values, function(d) { return d.x; })]);
        xden_yScale.domain([0, 1.1 * d3.max(data.x.density.values, function(d) { return d.y })])
        
        yden_xScale.domain([0, 1.1 * d3.max(data.y.density.values, function(d) { return d.y; })]);
        yden_yScale.domain([0, d3.max(data.y.density.values, function(d) { return d.x; })])
        
        xden_svg.select(".xden-x-axis").call(xden_xAxis);
        yden_svg.select(".yden-x-axis").call(yden_xAxis);
      }
      
      function updateDensity() {
        
                
        // Create density paths
        
        xden_line.x(function(d) { return xden_xScale(d.x); })
                 .y(function(d) { return xden_yScale(d.y); });
            
        yden_line.x(function(d) { return yden_xScale(d.y); })
                 .y(function(d) { return yden_yScale(d.x); });

        
        // Add density paths
        xden_line_path.attr("d", xden_line);
        yden_line_path.attr("d", yden_line);
        
        
        // Create selection area
        
        xden_select_area.x(function(d) { return xden_xScale(d.x); })
                        .y0(xden_height)
                        .y1(function(d) { return xden_yScale(d.y); });
                        
        yden_select_area.y(function(d) { return yden_yScale(d.x); })
                        .x0(yden_width)
                        .x1(function(d) { return yden_xScale(d.y); });
        
        
        xden_select_line.x(function(d) { return xden_xScale(d.x); })
                        .y(function(d) { return xden_yScale(d.y); });
        yden_select_line.x(function(d) { return yden_xScale(d.y); })
                        .y(function(d) { return yden_yScale(d.x); });
                  
          
        
        
          
        

        //xden_highlight.append("path")
        xden_select_area_path.datum(data.x.density.sortedValues.filter(function(d) {
                    return (data.x.selected.min <= d.x && d.x <= data.x.selected.max);
                  }))
            .attr("class", "area")
            .attr("d", xden_select_area);

        xden_select_line_path.datum(data.x.density.sortedValues.filter(function(d) {
                    return (data.x.selected.min <= d.x && d.x <= data.x.selected.max);
                  }))
          .attr("class", "line")
          .attr("d", xden_select_line);
        
        console.log("selected: ");
        console.log(data.y.selected);
        console.log(data.y.density.sortedValues.filter(function(d) {
                    return (data.y.selected.min <= d.x && d.x <= data.y.selected.max);
                  }));
        yden_select_area_path.datum(data.y.density.sortedValues.filter(function(d) {
                    return (data.y.selected.min <= d.x && d.x <= data.y.selected.max);
                  }))
            .attr("class", "area")
            .attr("d", yden_select_area);
        yden_select_line_path.datum(data.y.density.sortedValues.filter(function(d) {
                    return (data.y.selected.min <= d.x && d.x <= data.y.selected.max);
                  }))
          .attr("class", "line")
          .attr("d", yden_select_line);
          
        // TODO: need to make it so selection goes all the way up to window. Or else
        // handle case where only a few points are selects
        
        //var xden_brush = d3.svg.brush()
        xden_brush.x(xden_xScale)
            .extent([data.x.selected.min, data.x.selected.max])
            .on("brushstart", xbrushstart)
            .on("brush", xbrushmove)
            .on("brushend", xbrushend);
            
        yden_brush.y(yden_yScale)
            .extent([data.y.selected.min, data.y.selected.max])
            .on("brushstart", ybrushstart)
            .on("brush", ybrushmove)
            .on("brushend", ybrushend);
            
        //var xden_brushg = xden_svg.append("g")
          //.attr("class", "brush")
        xden_brushg.call(xden_brush);
        xden_brushg.selectAll("rect")
          .attr("height", xden_height);
          
        yden_brushg.call(yden_brush);
        yden_brushg.selectAll("rect")
          .attr("width", yden_width);
        
        xden_brushg.selectAll(".resize").append("path")
          .attr("transform", "translate(0," +  xden_height / 2 + ")")
          .attr("d", xden_select_handle);
        yden_brushg.selectAll(".resize").append("path")
          .attr("transform", "translate(" + yden_width / 2 + ", 0)")
          .attr("d", yden_select_handle);
        

            
        function xbrushstart() {
          
        }
        
        function xbrushmove() {
          console.log("start brushmove:");
          if (!d3.event.target.empty()) {
            var s = xden_brush.extent();
            data.x.selected.min = s[0];
            data.x.selected.max = s[1];
          } else {
            console.log("target empty");
            data.x.selected.min = d3.min(data.x.values);
            data.x.selected.max = d3.max(data.x.values);
          }
          updateScatterAxis("x")
          updateScatterCirclePositions("x");
          console.log("end brushmove:");
          console.log(xden_brush.extent());
        }
        
        function xbrushend() {
          console.log("start brushend");
          //svg.classed("selecting", !d3.event.target.empty());
          if (!d3.event.target.empty()) {
            var s = xden_brush.extent();
            console.log(s);
            
            data.x.selected.min = s[0];
            data.x.selected.max = s[1];
          } else {
            console.log("target empty");
            data.x.selected.min = d3.min(data.x.values);
            data.x.selected.max = d3.max(data.x.values);
          }
          updateScatterAxis("x");
          //updateScatterCircles();
          updateScatterCirclePositions("x");
          updateDensity();
          console.log("end brushend:");
          console.log(xden_brush.extent());
          console.log(data.x.selected);
          
          //scatter_xScale.domain(s);
          //scatter_svg.select(".x-axis").call(scatter_xAxis);
          //scatter_svg.selectAll("circle").transition()
          //    .attr("cx", function(d) { return scatter_xScale(d.x)});
          //generateVis();
        }
        
        function ybrushstart() {
          console.log("brushstart");
          var target = d3.event.target;
          for (var key in target) {
            console.log(key);
            if (target.hasOwnProperty(key)) {
              console.log(key + ": " + typeof target[key]);
            } else {
              console.log(key);
            }
          }
          console.log(d3.select(this));
        }
        
        function ybrushmove() {
          //console.log("start brushmove:");
          if (!d3.event.target.empty()) {
            var s = yden_brush.extent();
            console.log(s);
            
            data.y.selected.min = s[0];
            data.y.selected.max = s[1];
          } else {
            //console.log("target empty");
            data.y.selected.min = d3.min(data.y.values);
            data.y.selected.max = d3.max(data.y.values);
          }
          /*
          var s = xden_brush.extent();
          console.log(xden_brush.extent());
          data.x.selected.min = s[0];
          data.x.selected.max = s[1];
          */
          //scatter_xScale.domain([data.x.selected.min, data.x.selected.max]);
          //scatter_svg.selectAll("circle").transition()
            //  .attr("cx", function(d, i) { (i < 5) ? console.log(i + ": " + d.x + " -> " + scatter_xScale(d.x)) : null; return scatter_xScale(d.x)});
          
          //scatter_svg.select(".x-axis").call(scatter_xAxis);
          //updateScatter(data);
          //circles.classed("selected", function(d) { return s[0] <= d.x && d.x <= s[1]; });
          updateScatterAxis("y")
          updateScatterCirclePositions("y");
          //console.log("end brushmove:");
          //console.log(yden_brush.extent());
        }
        
        function ybrushend() {
          //console.log("start brushend");
          //svg.classed("selecting", !d3.event.target.empty());
          if (!d3.event.target.empty()) {
            var s = yden_brush.extent();
            console.log(s);
            
            data.y.selected.min = s[0];
            data.y.selected.max = s[1];
          } else {
            console.log("target empty");
            data.y.selected.min = d3.min(data.y.values);
            data.y.selected.max = d3.max(data.y.values);
          }
          updateScatterAxis("y");
          //updateScatterCircles();
          updateScatterCirclePositions("y");
          updateDensity();
          //console.log("end brushend:");
          //console.log(yden_brush.extent());
          //console.log(data.y.selected);
          
          //scatter_xScale.domain(s);
          //scatter_svg.select(".x-axis").call(scatter_xAxis);
          //scatter_svg.selectAll("circle").transition()
          //    .attr("cx", function(d) { return scatter_xScale(d.x)});
          //generateVis();
        }

        
          

      }
      
      // Load CSV and run vis
      d3.csv("inc_2012.csv", function(error, data) {
        console.log("Loading file...")
        if (error) {  // If error is not null, something went wrong.
          console.log(error);  // Log the error.
        } else {      // If no error, the file loaded correctly. Yay!
          console.log("Data:", data);   // Log the data.
          
          //Include other code to execute after successful file load here
          dataset = data.filter(function(d) {
            return (d['hh_moe'] / d['hh'] <= 0.2);
          });
          generateVis();
          //hideLoadingMsg();
        }
      });
      
      var map_svg = d3.select("#map-container")
          .append("svg")
            .attr("width", scatter_width + scatter_margin.left + scatter_margin.right)
            .attr("height", scatter_height + scatter_margin.top + scatter_margin.bottom)
          .append("g")
            .attr("transform", _do("translate", scatter_margin.left, scatter_margin.top));
            
      /*
      d3.json("SF_tracts_50p.json", function(json) {
        var projection = d3.geo.mercator()
                          .translate([scatter_width/2, scatter_height/2])
                          .center([-122.4391, 37.7631])
                          .scale(156000)
                        ;//.clipExtent([[-122.612285,37.706721],[-122.28178,37.929823999999996]]);
        var path = d3.geo.path().projection(projection);
        console.log(json.geometries);
        console.log(projection);
        map_svg.selectAll("path")
           .data(json.geometries)
           .enter()
           .append("path")
           .attr("d", path)
           .style("fill", "none")
           .style("stroke", "gray");
           
        console.log(json);
      });*/
      
      d3.json("gz_2010_06_140_00_500k/sf_tracts.json", function(json) {
          console.log(json);
          var projection = d3.geo.mercator()
                          .translate([scatter_width/2, scatter_height/2])
                          .center([-122.4391, 37.7631])
                          .scale(155000)
                        ;//.clipExtent([[-122.612285,37.706721],[-122.28178,37.929823999999996]]);
          
           color = d3.scale.quantize()
                    /*.range(["rgb(237,248,233)", "rgb(200,228,179)",
                     "rgb(186,196,118)", "rgb(150,163,84)","rgb(116,109,44)","rgb(80,248,233)", "rgb(49,228,179)",
                     "rgb(30,196,118)", "rgb(15,163,84)","rgb(0,109,44)"]);
                    */
                    .range(colorbrewer.Greens[9]);
          var path = d3.geo.path().projection(projection);
          if (dataset.length > 0) {
            console.log("HAS DATA");
            for (var i = 0; i < dataset.length; i++) {
              var data_d = dataset[i];
              var data_tract_id = data_d.tract_id;
              
              for (var j = 0; j < json.features.length; j++) {
                var json_d = json.features[j];
                json_d.properties.tract_id = parseInt(json_d.properties.STATE, 10) + json_d.properties.COUNTY + json_d.properties.TRACT;
                
                //console.log(data_tract_id + "; " + json_d.properties.tract_id);
                if (data_tract_id == json_d.properties.tract_id) {
                  json_d.properties.data = data_d;
                  break;
                }
              }
            }
          }
          // JUST A HACK WHILE TESTING
          color.domain([0,80]);
          map_svg.selectAll(".tract")
              .data(json.features)
            .enter()
              .append("path")
              .attr("class", function(d) {
                return "tract tract-" + d.properties.STATE + d.properties.COUNTY + d.properties.TRACT;
              })
              .attr("d", path)
              .style("fill", function(d, i) {
                  var data = d.properties.data;
                  if (data) { var value = data["vehicle theft (rate)"]; }
                  if (value /*&& value < 20*/) {
                    return color(value);
                  } else {
                    return "#ccc";
                  }
              });
      });
      /*
      d3.json("gz_2010_06_140_00_500k/sf_tracts_full_topo.json", function(json) {
        console.log(json);
        
        map_svg.append("path")
              .datum(topojson.feature()
      });*/
    </script>
  </body>
</html>