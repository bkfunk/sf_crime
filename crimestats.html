<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3 Test</title>
    <!--<link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/cupertino/jquery-ui.css">-->
    <link rel="stylesheet" href="style/style.css">
    <script type="text/javascript" src="lib/d3/d3.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.stats.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/colorbrewer/colorbrewer.js"></script>
    <script type="text/javascript" src="lib/topojson/topojson.v1.min.js"></script>
    <script type="text/javascript" src="lib/queue/queue.min.js"></script>
    <script type="text/javascript" src="lib/charts/density.js"></script>
    <script type="text/javascript" src="lib/charts/scatter.js"></script>
    <script type="text/javascript" src="lib/charts/map.js"></script>
    <!--<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//code.jquery.com/ui/1.10.4/jquery-ui.js"></script>-->
    <!--<script src="http://d3js.org/queue.v1.min.js"></script>-->
    
    <script type="text/javascript">
      function _do(f) {
        /* I get tired of all the "fn_name(" + arg + ")" business,
          so I use _do to take the (string) name of a function, then any number
          of arguments, and append them together into a string */
        var args = ""
        for (i=1; i < arguments.length; i++) {
          args += (i != 1) ? ", " + arguments[i] : arguments[i];
        }
        return f + "(" + args + ")";
      }
      
      
      function extractField(dataset, fieldName) {
        // Create field object, starting with the label
        var field = { label: fieldName };
        
        // Create an array of numeric (float) values
        field.values = dataset.map(function(d) {
          return parseFloat(d[fieldName]);
        });
        
        // Create an array of string values
        field.stringValues = dataset.map(function(d) {
          return d[fieldName];
        });
        
        // Create minimum and maximum functions for the field
        // This is just a shorthand.
        field.getMin = function() { return d3.min(field.values); };
        field.getMax = function() { return d3.max(field.values); };
        
        // Unlike the overall min/max, the selected min/max are set by us,
        // so they don't need to be functions, since they don't reflect the
        // dynamic state of the data
        field.selected = {
          min: field.getMin(),
          max: field.getMax()
        };
        
        // The function to select for values
        field.selected.selector = function(element) {
          return (element >= field.selected.min && element <= field.selected.max)
        };
        
        // A function returning the selected values
        /*field.selected.getValues = function() {
          return field.values.filter(field.selected.selector);
        };*/
        
        return field;
      }
    </script>
  </head>
  <body>
    <div id="main">
      <div id="info">
        Info
      </div>
      <div id="scatter-group-container">
        
        <div id="scatter-container" class="scatter plot-container">
        </div>
        
        <div id="y-density-container" class="y density plot-container">
        </div>
        
        <div id="x-density-container" class="x density plot-container">
        </div>
        
        <div id="corner-container">
        </div>
      </div>
      <div id="map-container">
      </div>
    </div>
    
    <script type="text/javascript">
      var mapdata, dataset, tracts;
      var scatter, xden, yden, map;
      
      // Initialize vis      
      function generateVis() {

        data = {
          x: extractField(dataset, "no_car_pct"),
          y: extractField(dataset, "vehicle theft (rate)"),
          id: extractField(dataset, "tract_id")
        }
        data.data = d3.zip(data.x.values, data.y.values, data.id.values)
                      .map(function(d) {
                        return {
                          x: d[0],
                          y: d[1],
                          id: d[2]
                        };
                      });
        
        data.isSelected = function(d) {
          return ((data.x.selected.min <= d.x && d.x <= data.x.selected.max) &&
                  (data.y.selected.min <= d.y && d.y <= data.y.selected.max));
        };
        
    // Scatter Plot
        scatter = scatterPlot();
        d3.select("#scatter-container")
            .datum(data)
            .call(scatter);//, data.data);
        scatter.addMarkerListener("mouseover", function(d, i) {
          d3.select("#info").text("x: " + d.x + " y: " + d.y + " id: " + d.id);
        });
        
    // X-density Plot
        xden = densityPlot();
        d3.select("#x-density-container")
          .datum(data)
          .call(xden, "x");
        xden.brushMoveListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        xden.brushEndListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    // Y-density Plot
        yden = densityPlot().value(function(d) {
          return d['y'];
        });
        d3.select("#y-density-container")
          .datum(data)
          .call(yden);
        yden.rotate(270);
        yden.brushMoveListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        yden.brushEndListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    // Map Plot
        map = multiMap();
        d3.select("#map-container")
          .datum(tracts)
          .call(map);
      }
      
      var loadedCSV = function(error, result) {
        console.log("Loaded CSV");
      };
      var loadedJSON = function(error, result) {
        console.log("Loaded JSON");
      };
      queue()
        .defer(d3.json, "geo/sf_tracts_topo_small.json")
        .defer(d3.csv, "data/rates/inc_2012.csv")
        .awaitAll(function(error, results) {
          //console.log(results);
          mapdata = results[0];
          dataset = results[1];
          tracts = topojson.feature(mapdata, mapdata.objects.sf_tracts);
          generateVis()
        });
      
      //d3.json("geo/gz_2010_06_140_00_500k/sf_tracts.json", function(json) {
      /*
      d3.json("geo/sf_tracts_topo_small.json", function(json) {
          console.log(json);
          json_data = json;
          var projection = d3.geo.mercator()
                          .translate([scatter_width/2, scatter_height/2])
                          .center([-122.4391, 37.7631])
                          .scale(155000)
                        ;//.clipExtent([[-122.612285,37.706721],[-122.28178,37.929823999999996]]);
          
           color = d3.scale.quantize()
                    .range(colorbrewer.Greens[9]);
                    
          var path = d3.geo.path().projection(projection);
          if (dataset.length > 0) {
            console.log("HAS DATA");
            for (var i = 0; i < dataset.length; i++) {
              var data_d = dataset[i];
              var data_tract_id = data_d.tract_id;
              
              for (var j = 0; j < json.features.length; j++) {
                var json_d = json.features[j];
                json_d.properties.tract_id = parseInt(json_d.properties.STATE, 10) + json_d.properties.COUNTY + json_d.properties.TRACT;
                
                //console.log(data_tract_id + "; " + json_d.properties.tract_id);
                if (data_tract_id == json_d.properties.tract_id) {
                  json_d.properties.data = data_d;
                  break;
                }
              }
            }
          }
          // JUST A HACK WHILE TESTING
          color.domain([0,80]);
          map_svg.selectAll(".tract")
              .data(topojson.feature(json))
            .enter()
              .append("path")
              .attr("class", function(d) {
                return "tract tract-" + d.properties.STATE + d.properties.COUNTY + d.properties.TRACT;
              })
              .attr("d", path)
              .style("fill", function(d, i) {
                  var data = d.properties.data;
                  if (data) { var value = data["vehicle theft (rate)"]; }
                  if (value) {
                    return color(value);
                  } else {
                    return "#ccc";
                  }
              });
      });*/
      /*
      d3.json("gz_2010_06_140_00_500k/sf_tracts_full_topo.json", function(json) {
        console.log(json);
        
        map_svg.append("path")
              .datum(topojson.feature()
      });*/
      
      /*
      d3.json("SF_tracts_50p.json", function(json) {
        var projection = d3.geo.mercator()
                          .translate([scatter_width/2, scatter_height/2])
                          .center([-122.4391, 37.7631])
                          .scale(156000)
                        ;//.clipExtent([[-122.612285,37.706721],[-122.28178,37.929823999999996]]);
        var path = d3.geo.path().projection(projection);
        console.log(json.geometries);
        console.log(projection);
        map_svg.selectAll("path")
           .data(json.geometries)
           .enter()
           .append("path")
           .attr("d", path)
           .style("fill", "none")
           .style("stroke", "gray");
           
        console.log(json);
      });*/
    </script>
  </body>
</html>