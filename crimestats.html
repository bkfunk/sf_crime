<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3 Test</title>
    <!--<link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/cupertino/jquery-ui.css">-->
    <link rel="stylesheet" href="style/style.css">
      
    <script type="text/javascript" src="lib/underscore/underscore-min.js"></script>
    <script type="text/javascript" src="lib/d3/d3.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.stats.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/colorbrewer/colorbrewer.js"></script>
    <script type="text/javascript" src="lib/topojson/topojson.v1.min.js"></script>
    <script type="text/javascript" src="lib/queue/queue.min.js"></script>
    <script type="text/javascript" src="lib/charts/twoway.js"></script>
    <script type="text/javascript" src="lib/charts/density.js"></script>
    <script type="text/javascript" src="lib/charts/scatter.js"></script>
    <script type="text/javascript" src="lib/charts/map.js"></script>
    
    <script type="text/javascript" src="lib/charts/test_scatter.js"></script>
    <!--<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//code.jquery.com/ui/1.10.4/jquery-ui.js"></script>-->
    <!--<script src="http://d3js.org/queue.v1.min.js"></script>-->
    
    <script type="text/javascript">
      function _do(f) {
        /* I get tired of all the "fn_name(" + arg + ")" business,
          so I use _do to take the (string) name of a function, then any number
          of arguments, and append them together into a string */
        var args = ""
        for (i=1; i < arguments.length; i++) {
          args += (i != 1) ? ", " + arguments[i] : arguments[i];
        }
        return f + "(" + args + ")";
      }
      
      function extractField(dataset, fieldName) {
        // Create field object, starting with the label
        var field = { label: fieldName };
        
        // Create an array of numeric (float) values
        field.values = dataset.map(function(d) {
          return parseFloat(d[fieldName]);
        });
        
        // Create an array of string values
        field.stringValues = dataset.map(function(d) {
          return d[fieldName];
        });
        
        // Create minimum and maximum functions for the field
        // This is just a shorthand.
        field.getMin = function() { return d3.min(field.values); };
        field.getMax = function() { return d3.max(field.values); };
        
        // Unlike the overall min/max, the selected min/max are set by us,
        // so they don't need to be functions, since they don't reflect the
        // dynamic state of the data
        field.selected = {
          min: field.getMin(),
          max: field.getMax()
        };
        
        // The function to select for values
        field.selected.selector = function(element) {
          return (element >= field.selected.min && element <= field.selected.max)
        };
        
        // A function returning the selected values
        /*field.selected.getValues = function() {
          return field.values.filter(field.selected.selector);
        };*/
        
        return field;
      }
      
      rotateElement = function(element, angle) {
        
        // NOTE Rotate cannot be chained
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        var selection = d3.select(element);
        
        // modulo out full rotations and convert to radians
        angle = angle % 360;
        theta = angle * (Math.PI / 180);
        //var H = height * Math.cos(theta) + width * Math.sin(theta);
        //var W = height * Math.sin(theta) + width * Math.cos(theta);
        //var H = height * Math.sin(theta);
        //var W = width  * Math.cos(theta);
        if (0 <= angle && angle < 90) {
          var dx = height * Math.sin(theta);
          var dy = 0;
          //var H = height * Math.cos(theta) + width * Math.sin(theta);
          //var W = height * Math.sin(theta) + width * Math.cos(theta);
        
        } else if (90 <= angle && angle < 180) {
          var dx = -width * Math.cos(theta) + height * Math.sin(theta);
          var dy = -height * Math.cos(theta);
          //var H = height * Math.cos(theta) - width * Math.sin(theta);
          //var W = height * Math.sin(theta) - width * Math.cos(theta);
        } else if (180 <= angle && angle < 270) {
          var dx = -width * Math.cos(theta);
          var dy = -width * Math.sin(theta) - height * Math.cos(theta);
          //var H = height * Math.cos(theta) + width * Math.sin(theta);
          //var W = height * Math.sin(theta) + width * Math.cos(theta);
        } else {
          var dx = 0;
          var dy = -width * Math.sin(theta);
          //var H = height * Math.cos(theta) - width * Math.sin(theta);
          //var W = height * Math.sin(theta) - width * Math.cos(theta);
          
        }
        
        //wScale = Math.abs(W / width);
        //hScale = Math.abs(H / height);
        selection.attr("transform", _do("translate", dx, dy) + " "
                           + _do("rotate", angle));
        return {"dx" : dx, "dy" : dy};
      };
      
    </script>
  </head>
  <body>
    <div id="main">
      <div id="selects">
        <label for="x-select">X Variable:</label>
        <select id="x-select"></select>
        
        <label for="y-select">Y Variable:</label>
        <select id="y-select"></select>
        
        <label for="map-select">Map Variable:</label>
        <select id="map-select"></select>
      </div>
      <div id="info"></div>
      <div id="scatter-group-container">
        
        <div id="scatter-container" class="scatter plot-container">
        </div>
        
        <div id="y-density-container" class="y density plot-container">
        </div>
        
        <div id="x-density-container" class="x density plot-container">
        </div>
        
        <div id="corner-container">
        </div>
      </div>
      <div id="map-container">
      </div>
    </div>
    
    <script type="text/javascript">
      var mapdata, dataset, tracts, borders;
      var scatter, xden, yden, map;
      var tractData;
      
      // Initialize vis      
      function generateVis() {        
        tractData = {
          index: [] //tracts.features.map(function(d) { return d.id; })
        };
        
        for (i in tracts.features) {
          var t = tracts.features[i];
          //var b = borders.coordinates[i];
          var id = "06075" + t.id; // append state ("06") and county ("075")
          tractData[id] = t;
          tractData.index[i] = id;
          //tractData[id]["border"] = b;
          tractData[id]["id"] = id;
        }
        
        for (i in dataset) { // for each element in the dataset (from CSV)
          var t = dataset[i];
          var id = "0" + t.tract_id; // CSV ID doesn't have initial zero
          if (tractData.hasOwnProperty(id)) {
            tractData[id]["data"] = t; // add data to corresponding tract geom.
          }
        }
        tractData["06075980300"].data = undefined;
        data = tractData.index.map(function (t) { // get the data attribute
          return tractData[t].data;
        }).filter(function(d) { // remove tracts with no data
          return (typeof d !== "undefined");
        });
        

        var idSeries = "tract_id";
        
        var xValue = function(d, i) { return +d[xSeries]; };
        var yValue = function(d, i) { return +d[ySeries]; };
        var idValue = function(d, i) { return "0" + d[idSeries]; };
        var mapField = function(d, i) { return mapSeries; };
        
        var dataFilter = function(name) {
          if (name.indexOf("rent") !== -1 ||
              name.indexOf("hisp") !== -1) return false; // excl. specific vars
          if (name.indexOf("_moe") !== -1) return false; // excl. margins of err
          if (name.indexOf("(rate)") !== -1) return true; // incl. rates
          if (name.indexOf("_pct") !== -1) return true; // incl. pcts
          if (name.indexOf("hh") !== -1 || // incl. specific variables
              name.indexOf("fertility") !== -1) return true;
          return false;
        };
        d3.selectAll("select").selectAll("option")
            .data(d3.keys(data[0]).filter(dataFilter))
          .enter()
            .append("option")
            .attr("value", function(d) { return d; })
            .text(function(d) { return d; });
        d3.select("#x-select").node().selectedIndex = 0;
        d3.select("#y-select").node().selectedIndex = 1;
        d3.select("#map-select").node().selectedIndex = 0;
        
        var xSeries = d3.select("#x-select").node().value;
        var ySeries = d3.select("#y-select").node().value;
        var mapSeries = d3.select("#map-select").node().value;
        
        
    // Map Plot
        map = multiMap();
        
        d3.select("#map-container")
          .datum(tractData)
          .call(map);
        
        map.addFeatureListener("mouseover", function(d, i) {
          //that.parentNode.appendChild(that);
          //console.log("EXT MOUSOVER", d3.selectAll(".tract-" + d.id));
          d3.selectAll(".tract-" + d.id)
            .classed("selected", true).each(function() {
              this.parentNode.appendChild(this); });
        }).addFeatureListener("mouseout", function(d, i) {
          //console.log("MOUSOUT", d);
          //if (typeof d.data !== "undefined")
            d3.selectAll(".tract-" + d.id) //idValue(d.data))
              .classed("selected", false);
        });
        
    // Scatter Plot
        scatter = scatterPlot().plotWidth(400).plotHeight(400)
          .xValue(function(d, i) { return +d[xSeries]; })
          .yValue(function(d, i) { return +d[ySeries]; })
          .idValue(function(d, i) { return "0" + d[idSeries]; });
        
        d3.select("#scatter-container")
            .datum(data)
            .call(scatter);
        
        scatter.addMarkerListener("mouseover", function(d, i) {
          d3.select("#info").text("x: " + xValue(d) + " y: " + yValue(d) + " id: " + idValue(d));
          map.svg().selectAll(".tract-" + idValue(d))
            .each(function(d, i) {
              map.triggerFeatureListener("mouseover", d, i, this) });
          d3.selectAll(".tract-" + idValue(d)).classed("selected", true);
        });
        scatter.addMarkerListener("mouseout", function(d, i) {
          d3.selectAll(".tract-" + idValue(d)).classed("selected", false);
        });
        
    // X-density Plot
        xden = densityPlot().plotWidth(400).plotHeight(100)
          .getValue(xValue);
          
        d3.select("#x-density-container")
          .datum(data)
          .call(xden);
          
        xden.brushMoveListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        xden.brushEndListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    // Y-density Plot
        yden = densityPlot().plotWidth(100).plotHeight(400)
          .getValue(function(d) {
            return +d[ySeries];
          })
          .showAxes("y")
          .flipAxis(true)
          .orientation("vertical");
          
        d3.select("#y-density-container")
          .datum(data)
          .call(yden);
          
        yden.brushMoveListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        yden.brushEndListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    
        
        
        // Variable selectors
        
        d3.selectAll("select")
          .on("change", function(a, d, i) {
              if (d3.event.target.id === "x-select") {
                xSeries = d3.event.target.value;
                scatter.updateData().updatePlot();
                xden.getValue(xValue).updateData().updatePlot();
              }
              if (d3.event.target.id === "y-select") {
                ySeries = d3.event.target.value;
                scatter.updateData().updatePlot();
                yden.getValue(yValue).updateData().updatePlot();
              }
              if (d3.event.target.id === "map-select") {
                mapSeries = d3.event.target.value;
                map.field(mapField);
                map.updateData().updateMap();
                scatter.updateMarkerPositions();
              }
          })
          
      }
      
      var loadedCSV = function(error, result) {
        console.log("Loaded CSV");
      };
      var loadedJSON = function(error, result) {
        console.log("Loaded JSON");
      };
      queue()
        //.defer(d3.json, "geo/sf_tracts_topo_small.json")
        .defer(d3.json, "geo/gz_2010_06_140_00_500k/sf_tracts_full_topo.json")
        .defer(d3.csv, "data/rates/inc_2012.csv")
        .awaitAll(function(error, results) {
          mapdata = results[0];
          dataset = results[1];
          tracts = topojson.feature(mapdata, mapdata.objects.sf_tracts);
          generateVis()
        });
        
    </script>
  </body>
</html>