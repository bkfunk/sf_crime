<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3 Test</title>
    <!--<link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/cupertino/jquery-ui.css">-->
    <link rel="stylesheet" href="style/less/style.css">
      
    <!--<script type="text/javascript" src="lib/underscore/underscore-min.js"></script>-->
    <script type="text/javascript" src="lib/d3/d3.js"></script>
    <!--script type="text/javascript" src="bower_components/d3/d3.js"></script>
    <script type="text/javascript" src="bower_components/d3-tip/index.js"></script-->
    <script type="text/javascript" src="lib/d3/lib/science/science.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/science/science.stats.min.js"></script>
    <script type="text/javascript" src="lib/d3/lib/colorbrewer/colorbrewer.js"></script>
    <script type="text/javascript" src="lib/topojson/topojson.v1.min.js"></script>
    <script type="text/javascript" src="lib/queue/queue.min.js"></script>
    <!--script type="text/javascript" src="lib/charts/twoway.js"></script-->
    <script type="text/javascript" src="lib/charts/density.js"></script>
    <script type="text/javascript" src="lib/charts/scatter.js"></script>
    <script type="text/javascript" src="lib/charts/map.js"></script>
    
    <script type="text/javascript" src="lib/tooltip.js"></script>
    
    <!--<script type="text/javascript" src="lib/charts/test_scatter.js"></script>
    <!--<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//code.jquery.com/ui/1.10.4/jquery-ui.js"></script>-->
    <!--<script src="http://d3js.org/queue.v1.min.js"></script>-->
    
    <script type="text/javascript">
      function _do(f) {
        /* I get tired of all the "fn_name(" + arg + ")" business,
          so I use _do to take the (string) name of a function, then any number
          of arguments, and append them together into a string */
        var args = ""
        for (i=1; i < arguments.length; i++) {
          args += (i != 1) ? ", " + arguments[i] : arguments[i];
        }
        return f + "(" + args + ")";
      }
      
      function extractField(dataset, fieldName) {
        // Create field object, starting with the label
        var field = { label: fieldName };
        
        // Create an array of numeric (float) values
        field.values = dataset.map(function(d) {
          return parseFloat(d[fieldName]);
        });
        
        // Create an array of string values
        field.stringValues = dataset.map(function(d) {
          return d[fieldName];
        });
        
        // Create minimum and maximum functions for the field
        // This is just a shorthand.
        field.getMin = function() { return d3.min(field.values); };
        field.getMax = function() { return d3.max(field.values); };
        
        // Unlike the overall min/max, the selected min/max are set by us,
        // so they don't need to be functions, since they don't reflect the
        // dynamic state of the data
        field.selected = {
          min: field.getMin(),
          max: field.getMax()
        };
        
        // The function to select for values
        field.selected.selector = function(element) {
          return (element >= field.selected.min && element <= field.selected.max)
        };
        
        // A function returning the selected values
        /*field.selected.getValues = function() {
          return field.values.filter(field.selected.selector);
        };*/
        
        return field;
      }
      
      rotateElement = function(element, angle) {
        
        // NOTE Rotate cannot be chained
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        var selection = d3.select(element);
        
        // modulo out full rotations and convert to radians
        angle = angle % 360;
        theta = angle * (Math.PI / 180);
        //var H = height * Math.cos(theta) + width * Math.sin(theta);
        //var W = height * Math.sin(theta) + width * Math.cos(theta);
        //var H = height * Math.sin(theta);
        //var W = width  * Math.cos(theta);
        if (0 <= angle && angle < 90) {
          var dx = height * Math.sin(theta);
          var dy = 0;
          //var H = height * Math.cos(theta) + width * Math.sin(theta);
          //var W = height * Math.sin(theta) + width * Math.cos(theta);
        
        } else if (90 <= angle && angle < 180) {
          var dx = -width * Math.cos(theta) + height * Math.sin(theta);
          var dy = -height * Math.cos(theta);
          //var H = height * Math.cos(theta) - width * Math.sin(theta);
          //var W = height * Math.sin(theta) - width * Math.cos(theta);
        } else if (180 <= angle && angle < 270) {
          var dx = -width * Math.cos(theta);
          var dy = -width * Math.sin(theta) - height * Math.cos(theta);
          //var H = height * Math.cos(theta) + width * Math.sin(theta);
          //var W = height * Math.sin(theta) + width * Math.cos(theta);
        } else {
          var dx = 0;
          var dy = -width * Math.sin(theta);
          //var H = height * Math.cos(theta) - width * Math.sin(theta);
          //var W = height * Math.sin(theta) - width * Math.cos(theta);
          
        }
        
        //wScale = Math.abs(W / width);
        //hScale = Math.abs(H / height);
        selection.attr("transform", _do("translate", dx, dy) + " "
                           + _do("rotate", angle));
        return {"dx" : dx, "dy" : dy};
      };
      
      
      function getOffsetRect(elem) {
          // Get bounding box (doesn't take scroll into consideration)
          var box = elem.getBoundingClientRect()
          
          var body = document.body
          var docElem = document.documentElement
          
          // Calculate scroll (different versions based on browsers)
          var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop
          var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft
          
          // document can be shifted in ID
          var clientTop = docElem.clientTop || body.clientTop || 0
          var clientLeft = docElem.clientLeft || body.clientLeft || 0
          
          // (4)
          var top  = box.top +  scrollTop - clientTop
          var left = box.left + scrollLeft - clientLeft
          
          return { top: Math.round(top), left: Math.round(left),
                  width: Math.round(box.width), height: Math.round(box.height) }
      }
    </script>
  </head>
  <body>
    <div id="main">
      <div id="selects">
        <label for="x-select">X Variable:</label>
        <select id="x-select"></select>
        
        <label for="y-select">Y Variable:</label>
        <select id="y-select"></select>
        
        <label for="map-select">Map Variable:</label>
        <select id="map-select"></select>
      </div>
      <div id="info"></div>
      <div id="scatter-group-container">
        
        <div id="scatter-container" class="scatter plot-container">
        </div>
        
        <div id="y-density-container" class="y density plot-container">
        </div>
        
        <div id="x-density-container" class="x density plot-container">
        </div>
        
        <div id="corner-container">
        </div>
      </div>
      <div id="map-container">
      </div>
      
      <div id="explanation">
        <p>I built this as a way to explore how to visualize several dimensions of data while also geographic patterns.</p>
        <p>You can use the handles on the density plots of the X and Y variable to restrict the scatter plot to a certain range. Doing so will also highlight the plotted points on the map by setting all tracts that are not on the scatter plot to grayscale. Use the select elements at the top to change variables; note that you can have the map showing one of the two variables on the scatter plot, or you could set it to a completely different variable.</p>
        <p>This is still a work in progress, in particular in terms of design/prettifying!</p>
      </div>
    </div>
    
    <script type="text/javascript">
      var mapdata, dataset, tracts, borders;
      var scatter, xden, yden, map;
      var tractData;
      
      // Initialize vis      
      function generateVis() {        
        tractData = {
          index: [] //tracts.features.map(function(d) { return d.id; })
        };
        
        for (i in tracts.features) {
          var t = tracts.features[i];
          //var b = borders.coordinates[i];
          var id = "06075" + t.id; // append state ("06") and county ("075")
          tractData[id] = t;
          tractData.index[i] = id;
          //tractData[id]["border"] = b;
          tractData[id]["id"] = id;
        }
        
        for (i in dataset) { // for each element in the dataset (from CSV)
          var t = dataset[i];
          var id = "0" + t.tract_id; // CSV ID doesn't have initial zero
          if (tractData.hasOwnProperty(id)) {
            tractData[id]["data"] = t; // add data to corresponding tract geom.
          }
        }
        
        tractData["06075980300"].data = undefined; // Golden Gate Park! Numbers are all weird, so we exclude it.
        
        data = tractData.index.map(function (t) { // get the data attribute
          return tractData[t].data;
        }).filter(function(d) { // remove tracts with no data
          return (typeof d !== "undefined");
        });
        

        var idSeries = "tract_id";
        
        // These functions can be used to dynamically get the right field
        // from the data.
        var xValue = function(d, i) { return +d[xSeries]; };
        var yValue = function(d, i) { return +d[ySeries]; };
        var idValue = function(d, i) { return "0" + d[idSeries]; };
        var mapField = function(d, i) { return mapSeries; };
        var mapValue = function(d, i) { return +d['data'][mapSeries]; };
        
        
        /* Set up selector inputs */
        
        // Remove certain variables we don't want
        var dataFilter = function(name) {
          if (name.indexOf("rent") !== -1 ||
              name.indexOf("hisp") !== -1) return false; // excl. specific vars
          if (name.indexOf("_moe") !== -1) return false; // excl. margins of err
          if (name.indexOf("(rate)") !== -1) return true; // incl. rates
          if (name.indexOf("_pct") !== -1) return true; // incl. pcts
          if (name.indexOf("hh") !== -1 || // incl. specific variables
              name.indexOf("fertility") !== -1) return true;
          return false;
        };
        
        // Bind data to selectors
        d3.selectAll("select").selectAll("option")
            .data(d3.keys(data[0]).filter(dataFilter))
          .enter()
            .append("option")
            .attr("value", function(d) { return d; })
            .text(function(d) { return d; });
            
        d3.select("#x-select").node().selectedIndex = 0;
        d3.select("#y-select").node().selectedIndex = 1;
        d3.select("#map-select").node().selectedIndex = 0;
        
        var xSeries = d3.select("#x-select").node().value;
        var ySeries = d3.select("#y-select").node().value;
        var mapSeries = d3.select("#map-select").node().value;
        
        
    // Map Plot
        map = multiMap();
        
        d3.select("#map-container")
          .datum(tractData)
          .call(map);
        
        var mapTooltip = Tooltip().direction("n");
        console.log(tractData);
        
        // Set custom tooltip directions for weird tracts
        tractData["06075017902"].direction = "e"; // Tresure island, and two tiny pieces near bayview
        tractData["06075060100"].direction = "e"; // Presidio
        
        d3.select("#map-container")
          .call(mapTooltip);
        
        
        map.addFeatureListener("mouseover", function(d, i) {
          //that.parentNode.appendChild(that);
          //console.log("EXT MOUSOVER", d3.selectAll(".tract-" + d.id));
          d3.selectAll(".tract-" + d.id)
            .classed("selected", true).each(function() {
              this.parentNode.appendChild(this); });
          mapTooltip.show(this, [[idSeries, idValue(d)],
                                 [mapSeries, mapValue(d)]], d["direction"]);
        }).addFeatureListener("mouseout", function(d, i) {
          //console.log("MOUSOUT", d);
          //if (typeof d.data !== "undefined")
            d3.selectAll(".tract-" + d.id) //idValue(d.data))
              .classed("selected", false);
            //mapTooltip.hide(d);
        });
        
    // Scatter Plot
        scatter = scatterPlot().plotWidth(400).plotHeight(400)
          .xValue(function(d, i) { return +d[xSeries]; })
          .yValue(function(d, i) { return +d[ySeries]; })
          .idValue(function(d, i) { return "0" + d[idSeries]; });
        
        d3.select("#scatter-container")
            .datum(data)
            .call(scatter);
        
        var scatterTooltip = Tooltip();
        d3.select("#scatter-container")
          .call(scatterTooltip);
        /*var scatterTooltip = d3.select("#scatter-container")
                                .append("div")
                                  .attr("class", "tooltip tooltip-scatter")
                                  .style("position", "absolute")
                                  .style("z-index", "10")
                                  .style("visibility", "hidden");*/
        
        //var scatterToolip = d3.tip()
        //                    .attr('class', 'tooltip tooltip-scatter')
        //                    .html(function(d) {
        //                      console.log(d);
        //                      var result =
        //                        "<ul class='tooltip-list'>" +
        //                          "<li><span class='var var-id'>" + idSeries + ":</span>" + idValue(d) + "</li>" +
        //                          "<li><span class='var var-x'>" + xSeries + ":</span> " + xValue(d) + "</li>" +
        //                          "<li><span class='var var-y'>" + ySeries + ":</span> " + yValue(d) + "</li>" +
        //                        "</ul>";
        //                      return result;
        //                    });
        //                    
        //d3.select("#scatter-container .main-svg").call(scatterToolip);
        /*
        function showTooltip(tooltip, triggerNode, html, direction) {
          direction = direction || "e";
          
          var bbox = getOffsetRect(triggerNode);
          var width = tooltip.property("clientWidth"),
              height = tooltip.property("clientHeight");
          
          var clippath = d3.select(triggerNode.ownerSVGElement)
                        .select(".clip-path")
                        .node();
          console.log(clippath);
          var scene = (clippath) ? getOffsetRect(clippath) :
                                    getOffsetRect(triggerNode.ownerSVGElement);
                        
          //var svgWidth = triggerNode.ownerSVGElement.clientWidth,
          //    svgHeight = triggerNode.ownerSVGElement.clientHeight;
          
          var left, top;
          var horizontal, vertical;
          
          var e_left = bbox.left + bbox.width;
          var w_left = bbox.left - width;
          var c_left = bbox.left + (bbox.width - width)/2;
          
          if ((direction.indexOf("e") !== -1 &&
                  e_left + width <= scene.left + scene.width) ||
              (direction.indexOf("w") !== -1 && w_left < scene.left)) { // EAST
            // If EAST and left of right edge
            // or WEST and left of left edge (out of bounds)
            // then EAST
            
            horizontal = "east";
            left = e_left;
          } else if ((direction.indexOf("w") !== -1 && w_left >= scene.left) ||
                     (direction.indexOf("e") !== -1 &&
                        e_left + width > scene.left + scene.width)) { // WEST
            // If WEST and right of left edge
            // or EAST and right of right edge (out of bounds)
            // then WEST
            
            horizontal = "west";
            left = w_left;
          } else { // CENTER
            if (c_left + width > scene.left + scene.width) { // too far right
              horizontal = "west";
              left = w_left;
            } else if (c_left < scene.left) { // too far left
              horizontal = "east";
              left = e_left;
            } else {
              horizontal = "center";
              left = c_left;
            }
          }
          
          var n_top = bbox.top - height;
          var s_top = bbox.top + bbox.height;
          var c_top = bbox.top + (bbox.height - height)/2;
      
          if ((direction.indexOf("n") !== -1 && n_top >= scene.top) ||
              (direction.indexOf("s") !== -1 &&
                  s_top + height > scene.top + scene.height)) {
            // If NORTH and below top
            // or SOUTH and below bottom (out of bounds)
            // then: NORTH
            
            vertical = "north";
            top = n_top;
          } else if ((direction.indexOf("s") !== -1 &&
                          s_top + heigth <= scene.top + scene.height) ||
                     (direction.indexOf("n") !== -1 && n_top < scene.top)) {
            // If SOUTH and above bottom
            // or NORTH and above top (out of bounds)
            // then: SOURTH
            
            vertical = "south";
            top = s_top;
          } else { // CENTER
            if (c_top < scene.top) { // too far up
              vertical = "south";
              top = s_top;
            } else if (c_top + height > scene.top + scene.height) {  // too far down
              vertical = "north"
              top = n_top;
            } else {
              vertical = "center";
              top = c_top;
            }
          }
          //console.log(scene);
          console.log("Top:", top, "Left:", left);
          console.log("Vertical: ", vertical, "Horizontal: ", horizontal);
          tooltip.style("visibility", "visible")
                        .style("left", left + "px")
                        .style("top", top + "px")
                        .classed(horizontal, true)
                        .classed(vertical, true)
                        .html("<div class='tooltip-body'></div>");
          
          var tooltipBody = tooltip.select('.tooltip-body');
          tooltipBody.html(html);
          
        }*/
        /*
        top:
          bottom 100%
          left 50%
          border-bottom-color
          margin-left
        
        right:
          top: 50%
          left: 100%
          border-left-color
          margin-top
          
        bottom:
          top 100%
          left: 50%
          border-top-color
          margin-left
        
        left:
          top: 50%
          right: 100%
          border-right-color
          margin-top
        */
        
        
        
        scatter.addMarkerListener("mouseover", function(d, i) {
          d3.select("#info").text("x: " + xValue(d) + " y: " + yValue(d) + " id: " + idValue(d));
          map.svg().selectAll(".tract-" + idValue(d))
            .each(function(d, i) {
              map.triggerFeatureListener("mouseover", d, i, this) });
          d3.selectAll(".tract-" + idValue(d)).classed("selected", true);
          scatterTooltip.show(this, [[idSeries, idValue(d)],
                                      [xSeries, xValue(d)],
                                      [ySeries, yValue(d)]]);
          //scatterToolip.show(d);
          //mapTooltip.show(d);
          
          /*var html = "<ul class='tooltip-list'>" +
                      "<li><span class='var var-id'>" + idSeries + ":</span>" + idValue(d) + "</li>" +
                      "<li><span class='var var-x'>" + xSeries + ":</span> " + xValue(d) + "</li>" +
                      "<li><span class='var var-y'>" + ySeries + ":</span> " + yValue(d) + "</li>" +
                    "</ul>";
          showTooltip(scatterTooltip, this, html, "w");*/
          
        });                
        scatter.addMarkerListener("mouseout", function(d, i) {
          d3.selectAll(".tract-" + idValue(d)).classed("selected", false);
          //scatterToolip.hide(d);
          //mapTooltip.hide(d);
        });
        
        
        
    // X-density Plot
        xden = densityPlot().plotWidth(400).plotHeight(100)
          .getValue(xValue);
          
        d3.select("#x-density-container")
          .datum(data)
          .call(xden);
          
        xden.brushMoveListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        xden.brushEndListener(function(brush) {
          scatter.updateAxes("x", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    // Y-density Plot
        yden = densityPlot().plotWidth(100).plotHeight(400)
          .getValue(function(d) {
            return +d[ySeries];
          })
          .showAxes("y")
          .flipAxis(true)
          .orientation("vertical");
          
        d3.select("#y-density-container")
          .datum(data)
          .call(yden);
          
        yden.brushMoveListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(false);
        });
        yden.brushEndListener(function(brush) {
          scatter.updateAxes("y", brush.extent());
          scatter.updateMarkerPositions(true);
        });
        
    
        
        
        // Variable selectors
        
        d3.selectAll("select")
          .on("change", function(a, d, i) {
              if (d3.event.target.id === "x-select") {
                xSeries = d3.event.target.value;
                scatter.updateData().updatePlot();
                xden.getValue(xValue).updateData().updatePlot();
              }
              if (d3.event.target.id === "y-select") {
                ySeries = d3.event.target.value;
                scatter.updateData().updatePlot();
                yden.getValue(yValue).updateData().updatePlot();
              }
              if (d3.event.target.id === "map-select") {
                mapSeries = d3.event.target.value;
                map.field(mapField);
                map.updateData().updateMap();
                scatter.updateMarkerPositions();
              }
          })
          
      }
      
      var loadedCSV = function(error, result) {
        console.log("Loaded CSV");
      };
      var loadedJSON = function(error, result) {
        console.log("Loaded JSON");
      };
      queue()
        //.defer(d3.json, "geo/sf_tracts_topo_small.json")
        .defer(d3.json, "geo/gz_2010_06_140_00_500k/sf_tracts_full_topo.json")
        .defer(d3.csv, "data/rates/inc_2012.csv")
        .awaitAll(function(error, results) {
          mapdata = results[0];
          dataset = results[1];
          tracts = topojson.feature(mapdata, mapdata.objects.sf_tracts);
          generateVis()
        });
        
    </script>
  </body>
</html>